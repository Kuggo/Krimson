from Constants import *
from ASTNodes import *


class SyntaxError(Enum):
    identifier_expected = 'Identifier expected'
    symbol_expected = '{} expected'
    symbol_expected_before = "'{}' expected before '{}'"
    expression_expected = 'Expression expected'
    type_expected = 'type expected'
    generic_expected = 'Generic type/value expected'
    cannot_assign_to_non_var = '{} is not a variable that can be assigned a value to'
    if_expected = 'if keyword expected before else'


class Parser:
    """Parses a collection of tokens generated by the Lexer

    By convention, each function should take care of its tokens and leave it ready for the next function to start
    reading the next token right away"""

    def __init__(self, tokens: list[Token]):
        self.tokens: list[Token] = tokens + [Separators.eof.value]
        """the token collection"""

        self.i: int = 0
        """index on the token input of the current token"""

        self.peak: Token = self.tokens[self.i]
        """current token pointed by index"""

        self.length = len(self.tokens)
        """length of the input token collection. To avoid calling ``len()`` on ``self.has_next()`` multiple times"""

        self.last = None
        """previous token pointed by index"""

        self.ast: Optional[ScopeNode] = None
        """output ScopeNode generated upon calling ``self.parse()``"""

        self.errors: list[Error] = []
        """collection of Errors found by the Parser upon calling ``self.parse()``"""
        return

    def parse(self):
        """
        Entry function for the whole parsing process. The program is parsed as a scoped node (stream of statements).

        program : scope
        """
        if len(self.tokens) > 0:
            self.ast = self.scope()
        return

    def scope(self) -> ScopeNode:
        """
        Parses the next statements until it finds its end and returns the ScopeNode
        
        The end is the ``}`` separator
        
        scope : {statement}

        :return: ScopeNode
        """

        statements = []
        last_statement = None
        start_tok = self.peak
        while self.has_next() and self.last != Separators.rcb.value:
            statement = self.statement(last_statement=last_statement)
            if statement is not None:
                statements.append(statement)

        self.advance()
        return ScopeNode(start_tok, statements)

    def statement(self, last_statement: Optional[Node] = None) -> Optional[Node]:
        """
        Parses the next statement until it find its end and returns the Node corresponding to the statement, or None if
        the statement contains syntax errors

        The end is a separator token such as ',' ';' ':', a new keyword, or the end of an expression

        statement : expression
                  | while_statement
                  | if_statement
                  | return_statement
                  | break_statement
                  | skip_statement
                  | scope_statement
                  | var_assign_statement
                  | var_define_statement
                  | func_define_statement
                  | class_define_statement

        :param: last_statement: The last statement processed on the scope
        :return: Node or None if an error occurred
        """
        if self.peak.tt == TT.KEYWORD:
            if self.peak.value == 'while':
                return self.while_statement()
            elif self.peak.value == 'if':
                return self.if_statement()
            elif self.peak.value == 'else':
                return self.else_statement(last_statement)
            elif self.peak.value == 'return':
                return self.return_statement()
            elif self.peak.value == 'break':
                return self.break_statement()
            elif self.peak.value == 'skip':
                return self.skip_statement()
            elif self.peak.value == 'var':
                return self.var_define_statement()
            elif self.peak.value == 'func':
                return self.func_define_statement()
            elif self.peak.value == 'class':
                return self.class_define_statement()
            else:
                assert False

        elif self.peak == Separators.lcb.value:
            return self.scope()

        else:
            return self.expression()

    def expression(self) -> Optional[ExpressionNode]:
        """
        Parses the next expression until it finds its end and returns an AST of the expression

        The end is defined by a separator token such as ',' ';' ':', a keyword, or by finding 2 tokens not connected
        with an operator

        expression : value
                   | unary_operator expression
                   | expression binary_operator expression
                   | function_call

        :return: ExpressionNode
        """

        def is_last_tok_value(start):
            """Detects if the last non separator token was a variable/literal, within a certain range"""
            i = self.i - 1
            while i >= start and self.tokens[i].value in (')', ']'):
                i -= 1

            return i >= start and self.tokens[i].tt in (TT.IDENTIFIER, TT.LITERAL)

        expression_queue: list[(Token, Node)] = []
        operator_stack: list[Token] = []
        start_index = self.i
        while self.has_next():
            if self.peak.tt == TT.LITERAL:
                expression_queue.append(self.peak)

            elif self.peak.tt == TT.IDENTIFIER:
                if self.preview().value == '(':
                    func_call = self.function_call()
                    if func_call is not None:
                        expression_queue.append(func_call)
                else:
                    expression_queue.append(self.peak)

            elif self.peak.tt == TT.SEPARATOR:
                if self.peak.value == '(':
                    operator_stack.append(self.peak)

                elif self.peak.value == ')':
                    while len(operator_stack) > 0 and operator_stack[-1].value != '(':
                        expression_queue.append(operator_stack.pop())
                    if len(operator_stack) > 0:
                        operator_stack.pop()
                    else:
                        self.error(SyntaxError.symbol_expected_before, self.peak, '(', ')')

                elif self.peak.value == '[':
                    if is_last_tok_value(start_index):
                        self.peak.tt = TT.OPERATOR  # changing its status to operator
                        self.peak.value = '[]'
                        operator_stack.append(self.peak)
                    else:
                        arr = self.array_literal()
                        if arr is not None:
                            expression_queue.append(arr)

                elif self.peak.value == ']':
                    while len(operator_stack) > 0 and operator_stack[-1].value != '[':
                        expression_queue.append(operator_stack.pop())
                    if len(operator_stack) > 0:
                        expression_queue.append(operator_stack.pop())
                    else:
                        self.error(SyntaxError.symbol_expected_before, self.peak, '[', ']')

                elif self.peak.value == '{':
                    dict_set = self.dict_set_literal()
                    if dict_set is not None:
                        expression_queue.append(dict_set)

                else:
                    self.advance()
                    break

            elif self.peak.tt == TT.OPERATOR:
                if len(operator_stack) == 0 or operator_stack[-1].value == '(':
                    operator_stack.append(self.peak)
                else:
                    while len(operator_stack) > 0 and \
                            operator_precedence[self.peak.value] <= operator_precedence[operator_stack[-1].value]:
                        expression_queue.append(operator_stack.pop())
                    operator_stack.append(self.peak)

            else:
                assert False

            self.advance()
            if self.peak.tt == TT.KEYWORD or \
                    (self.peak.tt in (TT.IDENTIFIER, TT.LITERAL) and is_last_tok_value(start_index)):
                break

        while len(operator_stack) > 0:
            expression_queue.append(operator_stack.pop())

        operand_stack: list[ExpressionNode] = []
        for tok in expression_queue:
            if isinstance(tok, ExpressionNode):
                operand_stack.append(tok)

            elif tok.tt == TT.LITERAL:
                operand_stack.append(ValueNode(tok))

            elif tok.tt == TT.IDENTIFIER:
                operand_stack.append(VariableNode(tok))

            elif tok.tt == TT.OPERATOR:
                if tok.value in UNARY_OPERATORS:
                    if len(operand_stack) >= 1:
                        node = operand_stack.pop()
                        operand_stack.append(UnOpNode(tok, node))
                    else:
                        self.error(SyntaxError.expression_expected, tok)
                else:
                    if len(operand_stack) >= 2:
                        node2 = operand_stack.pop()
                        node1 = operand_stack.pop()
                        if tok.value in ASSIGN_OPERATORS:
                            var_assign = self.var_assign_statement(node1, node2, tok)
                            if var_assign is not None:
                                operand_stack.append(var_assign)

                        elif tok == Operators.index.value:
                            operand_stack.append(IndexOperatorNode(tok, node1, node2))

                        else:
                            operand_stack.append(BinOpNode(tok, node1, node2))
                    else:
                        self.error(SyntaxError.expression_expected, tok)

            else:
                print(tok)
                assert False

        if len(operand_stack) != 1:
            return None     # no expression found
        else:
            return operand_stack[0]

    def function_call(self):
        pass

    def while_statement(self) -> Optional[WhileNode]:
        """
        Parses the next while statement until it finds its end

        :return: WhileNode or None if an error was found
        """
        start = self.peak
        self.advance()

        condition = self.expression()
        if condition is None:
            self.error(SyntaxError.expression_expected, self.peak)

        body = self.statement()
        if body is None:
            return None

        return WhileNode(start, condition, body)

    def if_statement(self) -> Optional[IfNode]:
        """
        Parses the next if statement until it finds its end. It does not check for else statement after it is done.

        :return: IfNode or None if an error was found
        """
        start = self.peak
        self.advance()

        condition = self.expression()
        if condition is None:
            self.error(SyntaxError.expression_expected, self.peak)

        body = self.statement()
        if body is None:
            return None

        return IfNode(start, condition, body)

    def else_statement(self, last_statement: Optional[Node]) -> Optional[ElseNode]:
        """
        Parses the next else statement until its end

        :param: last_statement: The last statement processed on the scope
        :return: ElseNode or None if error was found (no previous if statement error)
        """
        if last_statement is not None and last_statement.repr_token != Keywords.if_:
            self.error(SyntaxError.if_expected, self.peak)
            return None

        start = self.peak
        self.advance()
        body = self.statement()
        return ElseNode(start, body)

    def return_statement(self) -> ReturnNode:
        """
        Parses the return statement until it finds its end.

        return_statement : 'return' [expression]

        :return: ReturnNode
        """
        start = self.peak
        self.advance()

        value = self.expression()

        return ReturnNode(start, value)

    def break_statement(self) -> BreakNode:
        """
        Parses the break statement until it finds its end.

        break_statement : 'break' [literal]

        :return: BreakNode
        """

        start = self.peak
        self.advance()
        value = None
        if self.peak.tt == TT.LITERAL and isinstance(self.peak.value, int):
            value = self.peak.value

        return BreakNode(start, value)

    def skip_statement(self) -> SkipNode:
        """
        Parses the break statement until it finds its end.

        skip_statement : 'skip' [literal]

        :return: SkipNode
        """

        start = self.peak
        self.advance()
        value = None
        if self.peak.tt == TT.LITERAL and isinstance(self.peak.value, int):
            value = self.peak.value

        return SkipNode(start, value)

    def macro_define_statement(self):
        pass

    def make_type(self, generic=False) -> Optional[Type]:
        """
        Parses the next type and returns it.

        Generics specified between <> will be added as part of the type. Nesting types in generics also works

        type : identifier ['<' {type} '>']

        :param: generic: if the type to be parsed is inside generic declarations
        :return: Type or None if an error occurred
        """

        if self.peak.tt != TT.IDENTIFIER and not generic:
            self.error(SyntaxError.generic_expected, self.peak)
            return None

        if self.peak.tt not in (TT.IDENTIFIER, TT.LITERAL) and generic:
            self.error(SyntaxError.generic_expected, self.peak)
            return None

        t = Type(self.peak)
        self.advance()

        if self.peak == Operators.lt.value:     # it contains a generic type
            self.advance()
            generics = []
            while self.has_next() and self.peak != Operators.gt.value:
                generic_type = self.make_type(generic=True)
                if generic_type is not None:
                    generics.append(generic_type)
                if self.peak.value in END_OF_EXPRESSION:
                    self.advance()

            self.advance()
            t.generics = generics

        return t

    def var_define_statement(self) -> Optional[VarDefineNode]:
        """
        Parses the next variable declaration statement and returns its Node

        var_define_statement : 'var' type identifier
                             | 'var' type var_assign_statement

        :return: VarAssignNode or None if an error occurred
        """
        start = self.peak
        self.advance()
        type_tok = self.peak
        var_type = self.make_type()
        if var_type is None:
            self.error(SyntaxError.type_expected, type_tok)
            return None

        var_name = self.peak
        if var_name.tt != TT.IDENTIFIER:
            self.error(SyntaxError.identifier_expected, self.peak)
            return None

        eq_symbol = self.preview()

        value = self.expression()

        if isinstance(value, AssignNode):
            return VarDefineNode(start, var_type, value.var, value.value)

        elif isinstance(value, VariableNode):
            return VarDefineNode(start, var_type, VariableNode(var_name), None)

        else:
            self.error(SyntaxError.symbol_expected, eq_symbol, '=')
            return None

    def var_assign_statement(self, node1, node2, tok) -> Optional[ExpressionNode]:
        """
        Parses the next variable assignment and returns its Node.
        It expands operate and assign operations such as ``+=``.

        var_assign_statement : identifier '=' expression

        :param node1: node containing the variable to be assigned the value to
        :param node2: node containing the value to be assigned to the variable
        :param tok: the assign token to be used to construct the resulting Node
        :return: AssignNode or None if an error occurred
        """
        if not isinstance(node1, VariableNode):
            self.error(SyntaxError.cannot_assign_to_non_var, node1.repr_token, node1.repr_token.value)
            return None

        if tok.value == '=':
            return AssignNode(node1, node2)
        else:
            tok.value = tok.value[:-1]
            return AssignNode(node1, BinOpNode(tok, node1, node2))

    def func_define_statement(self) -> Node:
        pass

    def class_define_statement(self) -> Node:
        pass

    def array_literal(self) -> ValueNode:
        """
        Parses and constructs an Array Literal from the next tokens and returns it.

        array : '[' {literal} ']'

        :return: ValueNode array literal
        """

        start_tok = self.peak
        self.advance()
        elements = []
        if self.peak == Separators.rbr.value:   # empty array
            return ValueNode(Token(TT.LITERAL, elements, start_tok.start, self.peak.end, start_tok.line))

        while self.has_next() and (self.last.value != ']'):
            value = self.expression()
            if value is None:
                self.error(SyntaxError.expression_expected, self.peak)
            else:
                elements.append(value)

        return ValueNode(Token(TT.LITERAL, elements, start_tok.start, self.peak.end, start_tok.line))

    def dict_set_literal(self):     # TODO
        pass
        """start = self.peak
        self.advance()
        if self.peak == Separators.rcb.value:
            return  # empty dict/set

        key = self.expression()
        is_dict = self.last == Separators.semi_col.value
        value = self.expression()

        while self.has_next() and self.last != Separators.rcb.value:
            pass"""

    def error(self, error: SyntaxError, tok: Token, *args) -> None:
        """
        Creates a new Error and adds it to the error collection of tokens ``self.errors``

        :param error: the error found
        :param tok: the token where it occurred
        :param args: extra arguments for custom error message formatting
        """
        self.errors.append(Error(error, tok.start, tok.end, tok.line, global_vars.PROGRAM_LINES[tok.line - 1], args))

    def advance(self, i=1) -> None:
        """
        Moves the index to i tokens ahead and updates all state variables

        :param i: number of tokens to advance
        """
        if self.i + i < len(self.tokens):
            self.i += i
            self.last = self.peak
            self.peak = self.tokens[self.i]
        else:
            self.peak = Separators.eof.value

    def preview(self, i=1) -> Token:
        """
        returns the token after ``i`` positions of current token

        :param i: offset of the position to look ahead
        :return: the token at the specified position
        """

        if self.has_next(i):
            return self.tokens[self.i + i]
        else:
            return Separators.eof.value

    def has_next(self, i=0) -> bool:
        """
        Checks if there are more tokens to be processed ``i`` tokens after the current index

        :param i: offset of current index
        :return: True if there are more tokens to be processed, False otherwise
        """
        return self.peak != Separators.eof.value and self.i + i < self.length
