from Lexer import *
from ASTNodes import *


class Parser:
    """Parses a collection of tokens generated by the Lexer

    By convention, each function should take care of its tokens and leave it ready for the next function to start
    reading the next token right away"""

    def __init__(self, tokens: list[Token]):
        self.tokens: list[Token] = tokens + [Separators.eof.value]
        self.i: int = 0
        self.peak: Token = self.tokens[self.i]
        self.last = None
        self.ast: Optional[ScopedNode] = None
        self.errors: list[Error] = []

    def parse(self):
        """ Entry function for the whole parsing process. The program is parsed as a scoped node (stream of statements).

        program : scopeNode"""
        if len(self.tokens) > 0:
            self.ast = self.scope()
        return

    def scope(self) -> ScopedNode:
        """"""

        statements = []
        start_tok = self.peak
        while self.has_next() and self.last != Separators.rcb.value:
            statement = self.statement()
            if statement is not None:
                statements.append(statement)

        self.advance()
        return ScopedNode(start_tok, statements)

    def statement(self) -> Optional[Node]:
        """
        Parses the next statement until it find its end and returns the Node corresponding to the statement, or None if
        the statement contains syntax errors

        The end is a separator token such as ',' ';' ':', a new keyword, or the end of an expression

        statement : expression
                  | while_statement
                  | if_statement
                  | return_statement
                  | break_statement
                  | skip_statement
                  | scope_statement
                  | var_assign_statement
                  | var_define_statement
                  | func_define_statement
                  | class_define_statement

        :return: Node or None if the statement had syntax errors
        """
        if self.peak.tt == TT.KEYWORD:
            if self.peak.value == 'while':
                return self.while_statement()
            elif self.peak.value == 'if':
                return self.if_statement()
            elif self.peak.value == 'return':
                return self.return_statement()
            elif self.peak.value == 'break':
                return self.break_statement()
            elif self.peak.value == 'skip':
                return self.skip_statement()
            elif self.peak.value == 'var':
                return self.var_define_statement()
            elif self.peak.value == 'func':
                return self.func_define_statement()
            elif self.peak.value == 'class':
                return self.class_define_statement()
            else:
                assert False

        elif self.peak == Separators.lcb.value:
            return self.scope()

        else:
            return self.expression()

    def expression(self) -> ExpressionNode:
        """Parses the next expression until it finds its end and returns an AST of the expression

        The end is defined by a separator token such as ',' ';' ':', a keyword, or by finding 2 tokens not connected
        with an operator

        expression : value
                   | unary_operator expression
                   | expression binary_operator expression
                   | function_call

        :return: ExpressionNode
        """

        def is_last_tok_value(start):
            """Detects if the last non separator token was a variable/literal, within a certain range"""
            i = self.i - 1
            while i >= start and self.tokens[i].value in (')', ']'):
                i -= 1

            return i >= start and self.tokens[i].tt in (TT.NAME, TT.LITERAL)

        precedence = {  # TODO put all the operator precedences here
            '[]': 0,
            '+': 1,
            '-': 1,
            '*': 2,
            '/': 2,
            '^': 3,
            '&': 4,
            '(': 0,
        }
        expression_queue: list[(Token, Node)] = []
        operator_stack: list[Token] = []
        start_index = self.i
        while self.has_next():
            if self.peak.tt == TT.LITERAL:
                expression_queue.append(self.peak)

            elif self.peak.tt == TT.NAME:
                if self.preview().value == '(':
                    func_call = self.function_call()
                    if func_call is not None:
                        expression_queue.append(func_call)
                else:
                    expression_queue.append(self.peak)

            elif self.peak.tt == TT.SEPARATOR:
                if self.peak.value == '(':
                    operator_stack.append(self.peak)

                elif self.peak.value == ')':
                    while len(operator_stack) > 0 and operator_stack[-1].value != '(':
                        expression_queue.append(operator_stack.pop())
                    if len(operator_stack) > 0:
                        operator_stack.pop()
                    else:
                        self.error(E.symbol_expected_before, self.peak, '(', ')')

                elif self.peak.value == '[':
                    if is_last_tok_value(start_index):
                        self.peak.tt = TT.OPERATOR  # changing its status to operator
                        self.peak.value = '[]'
                        operator_stack.append(self.peak)
                    else:
                        arr = self.array_literal()
                        if arr is not None:
                            expression_queue.append(arr)

                elif self.peak.value == ']':
                    while len(operator_stack) > 0 and operator_stack[-1].value != '[':
                        expression_queue.append(operator_stack.pop())
                    if len(operator_stack) > 0:
                        expression_queue.append(operator_stack.pop())
                    else:
                        self.error(E.symbol_expected_before, self.peak, '[', ']')

                elif self.peak.value == '{':
                    dict_set = self.dict_set_literal()
                    if dict_set is not None:
                        expression_queue.append(dict_set)

                else:
                    self.advance()
                    break

            elif self.peak.tt == TT.OPERATOR:
                if len(operator_stack) == 0 or operator_stack[-1].value == '(':
                    operator_stack.append(self.peak)
                else:
                    while len(operator_stack) > 0 and precedence[self.peak.value] <= precedence[operator_stack[-1].value]:
                        expression_queue.append(operator_stack.pop())
                    operator_stack.append(self.peak)

            else:
                assert False

            self.advance()
            if self.peak.tt == TT.KEYWORD or (self.peak.tt in (TT.NAME, TT.LITERAL) and is_last_tok_value(start_index)):
                break

        while len(operator_stack) > 0:
            expression_queue.append(operator_stack.pop())

        operand_stack: list[ExpressionNode] = []
        for tok in expression_queue:
            if isinstance(tok, ExpressionNode):
                operand_stack.append(tok)

            elif tok.tt == TT.LITERAL:
                operand_stack.append(ValueNode(tok))

            elif tok.tt == TT.NAME:
                operand_stack.append(VariableNode(tok))

            elif tok.tt == TT.OPERATOR:
                if tok.value in UNARY_OPERATORS:
                    if len(operand_stack) >= 1:
                        node = operand_stack.pop()
                        operand_stack.append(UnOpNode(tok, node))
                    else:
                        self.error(E.expression_expected, tok)
                else:
                    if len(operand_stack) >= 2:
                        node2 = operand_stack.pop()
                        node1 = operand_stack.pop()
                        if tok.value in ASSIGN_OPERATORS:
                            var_assign = self.var_assign_statement(node1, node2, tok)
                            if var_assign is not None:
                                operand_stack.append(var_assign)

                        elif tok == Operators.index.value:
                            operand_stack.append(IndexOperatorNode(tok, node1, node2))

                        else:
                            operand_stack.append(BinOpNode(tok, node1, node2))
                    else:
                        self.error(E.expression_expected, tok)

            else:
                print(tok)
                assert False

        assert len(operand_stack) == 1

        return operand_stack[0]

    def function_call(self):
        pass

    def while_statement(self) -> Node:
        start = self.peak
        self.advance()

        return

    def if_statement(self) -> Node:
        pass

    def return_statement(self) -> Node:
        pass

    def break_statement(self) -> Node:
        pass

    def skip_statement(self) -> Node:
        pass

    def macro_define_statement(self):
        pass

    def make_type(self) -> Token:
        """find the next type and returns it"""

        t = self.peak
        self.advance()
        if self.peak == Operators.lt.value:
            pass  # TODO for now no generics, but must add them later, and create a Type class that contains the
            # information about the type
        return t

    def var_define_statement(self) -> Optional[VarDefineNode]:
        """Parses the next variable declaration statement and returns its Node

        var_define_statement : 'var' name
                             | 'var' name '=' expression

        :return: VarAssignNode"""
        self.advance()
        var_type = self.make_type()
        var_name = self.peak
        if var_name.tt != TT.NAME:
            self.error(E.name_expected, self.peak)
            return None

        eq_symbol = self.preview()

        value = self.expression()

        if isinstance(value, AssignNode):
            return VarDefineNode(var_type, var_type, value.var, value.value)

        elif isinstance(value, VariableNode):
            return VarDefineNode(var_type, var_type, VariableNode(var_name), None)

        else:
            self.error(E.symbol_expected, eq_symbol, '=')
            return None

    def var_assign_statement(self, node1, node2, tok) -> Optional[ExpressionNode]:
        if not isinstance(node1, VariableNode):
            self.error(E.cannot_assign_to_non_var, node1.repr_token, node1.repr_token.value)
            return None

        if tok.value == '=':
            return AssignNode(node1, node2)
        else:
            tok.value = tok.value[:-1]
            return AssignNode(node1, BinOpNode(tok, node1, node2))

    def func_define_statement(self) -> Node:
        pass

    def class_define_statement(self) -> Node:
        pass

    def array_literal(self) -> ValueNode:
        start_tok = self.peak
        self.advance()
        elements = []
        while self.has_next() and self.last.value != ']':
            elements.append(self.expression())

        return ValueNode(Token(TT.LITERAL, elements, start_tok.start, self.peak.end, start_tok.line))

    def dict_set_literal(self) -> Optional[ValueNode]:
        pass
        """start = self.peak
        self.advance()
        if self.peak == Separators.rcb.value:
            return  # empty dict/set

        key = self.expression()
        is_dict = self.last == Separators.semi_col.value
        value = self.expression()

        while self.has_next() and self.last != Separators.rcb.value:
            pass"""

    def error(self, error: E, tok: Token, *args):
        self.errors.append(Error(error, tok.start, tok.end, tok.line, PROGRAM_LINES[tok.line - 1], args))

    def advance(self, i=1):
        if self.i + i < len(self.tokens):
            self.i += i
            self.last = self.peak
            self.peak = self.tokens[self.i]
        else:
            self.peak = Separators.eof.value

    def preview(self, i=1) -> Token:
        if self.has_next(i):
            return self.tokens[self.i + i]
        else:
            return Separators.eof.value

    def has_next(self, i=0):
        return self.peak != Separators.eof.value and self.i + i < len(self.tokens)
