// TODO add all the implementation for the methods if necessary
// TODO remake the file with the new syntax


bool: type {}

bool __or__(bool other) {

}

bool __and__(bool other) {

}

bool __xor__(bool other) {

}

bool __not__() {

}

nat {     // aka uint
    nat _;

    nat __add__(nat other) {

    }

    nat __sub__(nat other) {

    }

    int __inc__() {

    }

    int __dec__() {

    }

    nat __shr__(nat amount) {

    }

    nat __shl__(nat amount) {

    }

    nat __mlt__(nat other) {

    }

    nat __div__(nat other) {

    }

    nat __neg__() {

    }

    nat __bor__(nat other) {

    }

    nat __band__(nat other) {

    }

    nat __bxor__(nat other) {

    }

    nat __bnot__() {

    }

    bool __gt__(nat other) {

    }

    bool __gte__(nat other) {

    }

    bool __lt__(nat other) {

    }

    bool __lte__(nat other) {

    }

    bool __dif__(nat other) {

    }

    bool __equ__(nat other) {

    }
}

int {
    int _;

    int __add__(int other) {

    }

    int __sub__(int other) {

    }

    int __inc__() {

    }

    int __dec__() {

    }

    int __shr__(nat amount) {

    }

    int __shl__(nat amount) {

    }

    int __mlt__(int other) {

    }

    int __div__(int other) {

    }

    int __neg__() {

    }

    int __bor__(int other) {

    }

    int __band__(int other) {

    }

    int __bxor__(int other) {

    }

    int __bnot__() {

    }

    bool __gt__(int other) {

    }

    bool __gte__(int other) {

    }

    bool __lt__(int other) {

    }

    bool __lte__(int other) {

    }

    bool __dif__(int other) {

    }

    bool __equ__(int other) {

    }
}

frac {    // aka fixed. To be used instead of floats
    frac _;

    frac __add__(frac other) {

    }

    frac __sub__(frac other) {

    }

    int __inc__() {

    }

    int __dec__() {

    }

    frac __shr__(nat amount) {

    }

    frac __shl__(nat amount) {

    }

    frac __mlt__(frac other) {

    }

    frac __div__(frac other) {

    }

    frac __neg__() {

    }

    bool __gt__(frac other) {

    }

    bool __gte__(frac other) {

    }

    bool __lt__(frac other) {

    }

    bool __lte__(frac other) {

    }

    bool __dif__(frac other) {

    }

    bool __equ__(frac other) {

    }
}

char {
    char _;

    char __add__(char other) {}

    str __mlt__(cint amount) {}

    bool __gt__(char other) {}

    bool __gte__(char other) {}

    bool __lt__(char other) {}

    bool __lte__(char other) {}

    bool __dif__(char other) {}

    bool __equ__(char other) {}
}

array[T] {
    array[T] __add__(array[T] other) {}

    array[T] __add__(T other) {}

    T __get__(nat i) {}

    null __set__(nat i) {}

    bool __dif__(array other) {}

    bool __equ__(array other) {}
}

str {  // until interfaces and inheritance comes, this will have its own type
    char __get__(nat index) {}

    str __add__(str other) {}

    str __add__(char other) {}

    str __mlt__(int amount) {}

    bool __gt__(str other) {}

    bool __gte__(str other) {}

    bool __lt__(str other) {}

    bool __lte__(str other) {}

    bool __dif__(str other) {}

    bool __equ__(str other) {}
}

/*
set[T] {
    set[T] __add__(set[T] other) {}

    set[T] __add__(T other) {}

    bool __dif__(set other) {}

    bool __equ__(set other) {}
}

dict[K, V] {
    dict[T] __add__(dict[T] other) {}

    T __get__(nat i) {}

    null __set__(nat i) {}

    bool __dif__(dict other) {}

    bool __equ__(dict other) {}
}

ref[T] {
    ref _;

    T __deref__() {

    }
}
*/


